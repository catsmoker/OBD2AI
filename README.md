# OBD2AI

OBD2AI is an Android app that connects to a vehicle's OBD-II adapter over Bluetooth, reads diagnostic trouble codes (DTCs) and live telemetry (speed, RPM, coolant temperature), and uses the OpenAI API to provide human-friendly assessments and suggested actions for detected fault codes.

This README explains how to configure, build and run the project locally, how to provide the OpenAI API key used by the app, and includes notes on permissions and troubleshooting.

## Features

- Discover and connect to Bluetooth OBD-II adapters (classic SPP and BLE-aware permissions).
- Read stored, pending and permanent DTCs from the vehicle.
- Monitor live data such as vehicle speed, engine RPM and coolant temperature.
- Use OpenAI (configured via `BuildConfig.OPENAI_API_KEY`) to generate a JSON assessment for each DTC with severity, title, details, implications and suggested actions.
- Integrates with Google Mobile Ads and Firebase Analytics (optional / demo ad id included).

## Repository layout (important files)

- `app/` — Android application module
	- `src/main/java/com/catsmoker/obd2ai/` — main Kotlin sources (Bluetooth & OBD helpers, UI fragments, OpenAI service)
	- `src/main/AndroidManifest.xml` — app manifest, permissions and features
	- `build.gradle.kts` — module Gradle configuration (reads OPENAI_API_KEY from `local.properties`)
- `build.gradle.kts`, `settings.gradle.kts`, `gradle/` — project build configuration

## Prerequisites

- JDK 17 or newer (project is configured for Java 17 / Kotlin jvmTarget = 17).
- Android SDK with API level 36 (compileSdk = 36) and matching build-tools (36.1.0).
- Android Studio (Arctic Fox / Bumblebee or newer recommended) or command-line Gradle.
- A physical Android device with Bluetooth (recommended) or an emulator with Bluetooth passthrough (emulators generally don't support Bluetooth hardware well).
- An OpenAI API key if you want the DTC assessments to be generated by OpenAI.

## Configure OpenAI API Key

The app reads the OpenAI API key at build time from `local.properties` and places it into `BuildConfig.OPENAI_API_KEY`.

1. In the project root create or edit `local.properties` and add the key:

	 OPENAI_API_KEY=sk-xxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxx

2. The app's Gradle config (`app/build.gradle.kts`) will read this value and inject it as a build config field for both `debug` and `release` builds. If the key is missing, an empty string will be injected and OpenAI calls will fail.

Security note: Do NOT commit `local.properties` or your API key to source control. Use environment-specific secret storage for CI and production.

## Build and run

Using Android Studio:

1. Open the project in Android Studio.
2. Let Gradle sync and download dependencies.
3. Build and run the app on a physical device (recommended).

From the command line (Unix/macOS/Linux):

```bash
./gradlew assembleDebug
adb install -r app/build/outputs/apk/debug/app-debug.apk
```

Notes:
- The app requires runtime permissions for Bluetooth and location. The manifest requests the necessary permissions for API levels up to and including modern scopes (`BLUETOOTH_SCAN`, `BLUETOOTH_CONNECT`, etc.).
- When targeting Android 12+ you may need to grant location and background location depending on how discovery is implemented and whether you want background scanning.

## Runtime permissions and Bluetooth

The app requests Bluetooth and location permissions at runtime. On devices running Android 12+ the manifest includes `BLUETOOTH_SCAN` and `BLUETOOTH_CONNECT`. On older devices it includes legacy `BLUETOOTH` and `BLUETOOTH_ADMIN` entries (with maxSdkVersion where appropriate).

When connecting to an OBD-II adapter, the app uses SPP UUID `00001101-0000-1000-8000-00805F9B34FB` and creates an RFCOMM socket to exchange OBD commands.

## How the OpenAI integration works

- The `OpenAIService` class constructs prompts to ask the OpenAI API to return a JSON object describing a DTC (severity, title, detail, implications, suggestedActions).
- The service uses the `aallam/openai-kotlin` client library and the model id default is set to `gpt-5-mini` in the code; you can change it in the `OpenAIService` initializer if desired.
- The app expects a strictly-structured JSON response and parses it into the `DtpCodeDTO` model.

If you do not want to use OpenAI, you can stub or bypass `OpenAIService` in the app.

## Troubleshooting

- Bluetooth connection fails:
	- Ensure the device has Bluetooth enabled and the app has the required permissions.
	- Make sure the OBD-II adapter is powered and in pairing mode.
	- If using classic SPP, verify the adapter supports RFCOMM; many ELM327 clones do.

- OpenAI requests fail:
	- Verify `local.properties` contains a valid key.
	- Check device network connectivity.
	- Review logcat output for HTTP/SDK errors.

- Gradle/SDK issues:
	- Ensure your Android SDK has API 36 and build-tools 36.1.0 installed.
	- If Kotlin or plugin versions differ, follow Gradle sync errors to update tools.

## Developer notes & architecture

- The project is primarily Kotlin + Android Views/Fragments (no Jetpack Compose).
- Key classes:
	- `BluetoothHelper` — permission handling, discovery, pairing and establishing RFCOMM sockets.
	- `ObdHelper` — wraps the OBD connection and commands (uses `kotlin-obd` library).
	- `OpenAIService` — wraps calls to OpenAI and parses structured JSON into `DtpCodeDTO`.
	- `UIComponents.kt` — contains fragments and RecyclerView adapters for connection flow, error overview/detail and live data display.

The code is designed with coroutines and uses `Dispatchers.IO` for blocking I/O operations.

## Contributing

Contributions are welcome. If you open a pull request, please:

- Include a clear description of the change and why it is needed.
- Keep the changes focused and add tests where appropriate.
- Do not commit secrets (API keys) to the repository.

If you'd like to contribute, please follow these steps:

1. Fork the repository and create a feature branch using a descriptive name, for example:

	`git checkout -b feat/add-new-obd-command`

2. Make changes in your branch. Keep commits small and focused. Use clear commit messages.

3. Run the project locally and ensure your changes don't break existing functionality.

4. Open a pull request against `main` with a concise description of what you changed and why. Link any related issues.

PR checklist (please ensure before requesting review):

- [ ] The code builds and runs locally.
- [ ] No sensitive data or secrets are included.
- [ ] Unit tests or small integration tests are added for notable logic changes where appropriate.
- [ ] Code follows the repository style and formatting.
- [ ] Update documentation (README or inline docs) if public behavior changed.

If you want to report a bug or request a feature, open an issue and include logs, device details and reproduction steps where possible. For larger features, it helps to open an issue first to discuss the design.

Maintainers: when merging changes, squash small fixup commits and prefer clear single-commit histories for features.

## License

See `LICENSE` in the repository root.

## Contact

For questions or feedback, open an issue in this repository.


## Open-source tools & libraries used

This project uses (or references) several open-source libraries and tools. Below is a non-exhaustive list driven by the Gradle module dependencies and project sources:

- Kotlin Standard Library and Kotlin Coroutines (via AndroidX lifecycle/runtime and suspend usage)
- AndroidX Core KTX (`androidx.core:core-ktx`) and AppCompat
- AndroidX ConstraintLayout
- Material Components for Android (`com.google.android.material:material`)
- SpeedView library (`com.github.anastr:speedviewlib`) for the speedometer UI
- androidx.swiperefreshlayout for pull-to-refresh
- androidx.navigation (fragment and ui KTX) for navigation between fragments
- kotlin-obd (`com.github.eltonvs:kotlin-obd` or similar) — OBD-II command and connection helpers
- aallam/openai-kotlin (`com.aallam.openai:client`) — OpenAI client library used to call the API
- Ktor OkHttp engine (`io.ktor:ktor-client-okhttp`) used by the OpenAI client
- slf4j nop (`org.slf4j:slf4j-nop`) — lightweight no-op logger binding used for dependencies that require SLF4J
- Google Mobile Ads SDK (`com.google.android.gms:play-services-ads`) — for ad integration (demo app id used)
- Firebase Analytics (`com.google.firebase:firebase-analytics-ktx`) — for basic analytics

All of the above are installed and managed via Gradle. See `app/build.gradle.kts` and `gradle/libs.versions.toml` for exact artifacts and versions.

If you depend on any of these libraries in your contributions, please follow each library's license (typically Apache-2.0, MIT or similar). If you need help identifying a license for a specific dependency, open an issue and include the dependency coordinates.
